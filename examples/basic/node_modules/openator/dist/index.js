import { JsonOutputParser } from '@langchain/core/output_parsers';
import { SystemMessage, HumanMessage } from '@langchain/core/messages';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import * as crypto$1 from 'crypto';
import { EventEmitter } from 'events';
import { convertHtmlToMarkdown } from 'dom-to-semantic-markdown';
import { JSDOM } from 'jsdom';
import { chromium } from 'playwright';
import { ChatOpenAI } from '@langchain/openai';
import 'dotenv/config';

class EvaluationAgentSystemPrompt {
    constructor() { }
    getSystemPrompt() {
        return `
     As an evaluator, you will be presented with three primary components to assist you in your role:

    1. Web Task Instruction: This is a clear and specific directive provided in natural language, detailing the online activity to be carried out. These requirements may include conducting searches, verifying information, comparing prices, checking availability, or any other action relevant to the specified web service (such as Amazon, Apple, ArXiv, BBC News, Booking etc).

    2. Result Screenshots: This is a visual representation of the screen showing the result or intermediate state of performing a web task. It serves as visual proof of the actions taken in response to the instruction, and may not represent everything the agent sees.

    3. Result Response: This is a textual response obtained after the execution of the web task. It serves as textual result in response to the instruction.
    
    4. Task History Summary: This is a summary of the task history of the agent, it serves as context proof of the actions performed by the agent.

    5. Previous Task Result: This is the result of the previous task, it serves as context proof of the decision making of the agent.

    
    -- You DO NOT NEED to interact with web pages or perform actions such as booking flights or conducting searches on websites.
    -- You SHOULD NOT make assumptions based on information not presented in the screenshot when comparing it to the instructions. If you cannot find any information in the screenshot that matches the instruction, you can believe the information in the response.
    -- Your primary responsibility is to conduct a thorough assessment of the web task instruction against the outcome depicted in the screenshot and in the response, evaluating whether the actions taken align with the given instructions.
    -- NOTE that the instruction may involve more than one task, for example, locating the garage and summarizing the review. Failing to complete either task, such as not providing a summary, should be considered unsuccessful.
    -- NOTE that the screenshot is authentic, but the response provided by LLM is generated at the end of web browsing, and there may be discrepancies between the text and the screenshots.
    -- Note the difference: 1) Result response may contradict the screenshot, then the content of the screenshot prevails, 2) The content in the Result response is not mentioned on the screenshot, choose to believe the content.
    -- If you are not sure whether you should believe the content in the response, you should choose unknown.

    You should elaborate on how you arrived at your final evaluation and then provide a definitive verdict on whether the task has been successfully accomplished, either as 'success', 'failed', or 'unknown'.

    If your verdict is 'failed', you must provide a 'hint' and a 'memoryLearning' to the user to improve the result. 
    This hint could be ideas of actions to perform to find the information you need.
    The memoryLearning is a string that will explain the agent what it should not do or what it should do differently later if he is in the same situation.

    IMPORTANT RULE: you must answer in JSON format including the result and explanation fields.

    Example 1:
    { "result": "success", "explanation": "From the two latest screenshots, we can see that the agent has successfully found the recipe and provided a summary of the reviews.", "hint": null }

    Example 2:
    { "result": "failed", "memoryLearning": "'Easy Vegetarian Spinach Lasagna was not a good choice'", "explanation": "The task was to find a vegetarian lasagna recipe with more than 100 reviews and a rating of at least 4.5 stars. The 'Easy Vegetarian Spinach Lasagna' has a rating of 4.6 stars but only 92 reviews, which does not meet the requirement of more than 100 reviews", "hint": "Go back and search for a recipe with more than 100 reviews." }

    Example 3:
    { "result": "failed", "memoryLearning": "'Cheese Burger should not be selected again'", "explanation": "The task was to find a vegetarian lasagna recipe with more than 100 reviews and a rating of at least 4.5 stars. The 'Cheese Burger' is not a vegetarian recipe", "hint": "Go back and search for a vegetarian recipe." }

    Example 3:
    { "result": "unknown", "memoryLearning": null, "explanation": "The agent did not provide a summary of the reviews." }
    `;
    }
    getSystemMessage() {
        return new SystemMessage({
            content: this.getSystemPrompt(),
        });
    }
}
class EvaluationAgentUserPrompt {
    constructor() { }
    getUserPrompt({ pageUrl, task, answer, screenshotCount, taskHistorySummary, previousTaskResult, }) {
        return `
    CURRENT PAGE URL: ${pageUrl}
    TASK: ${task}  
    RESULT RESPONSE: ${answer}
    ${screenshotCount} screenshot at the end:
    TASK HISTORY SUMMARY: ${taskHistorySummary}
    PREVIOUS TASK RESULT: ${previousTaskResult}
    `;
    }
    getUserMessage({ pageUrl, screenshotUrls, task, answer, taskHistorySummary, previousTaskResult, }) {
        if (!screenshotUrls.length) {
            throw new Error('No screenshot URLs provided to the evaluation agent');
        }
        const last3Screenshots = screenshotUrls.slice(-3);
        const screenshotPrompts = last3Screenshots.map((url) => {
            return {
                type: 'image_url',
                image_url: {
                    url,
                    detail: 'high',
                },
            };
        });
        return new HumanMessage({
            content: [
                {
                    type: 'text',
                    text: this.getUserPrompt({
                        pageUrl,
                        task,
                        answer,
                        screenshotCount: last3Screenshots.length,
                        taskHistorySummary,
                        previousTaskResult,
                    }),
                },
                ...screenshotPrompts,
            ],
        });
    }
}

class FeedbackAgent {
    constructor(llmService) {
        this.llmService = llmService;
    }
    async evaluate({ pageUrl, screenshotUrls, task, answer, taskHistorySummary, previousTaskResult, }) {
        const systemMessage = new EvaluationAgentSystemPrompt().getSystemMessage();
        const humanMessage = new EvaluationAgentUserPrompt().getUserMessage({
            pageUrl,
            screenshotUrls,
            task,
            answer,
            taskHistorySummary,
            previousTaskResult,
        });
        const parser = new JsonOutputParser();
        const response = await this.llmService.invokeAndParse([systemMessage, humanMessage], parser);
        console.log('FeedbackAgent response', JSON.stringify(response, null, 2));
        return response;
    }
}

const ManagerAgentActionSchema = z
    .union([
    z.object({
        name: z.literal('extractContent'),
        params: z.null(),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Extract the content of the current page'"),
    }),
    z.object({
        name: z.literal('clickElement'),
        params: z.object({
            index: z.number(),
        }),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Click the login button'"),
    }),
    z.object({
        name: z.literal('fillInput'),
        params: z.object({
            index: z.number(),
            text: z.string(),
        }),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Fill the email input'"),
    }),
    z.object({
        name: z.literal('goBack'),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Go back to the previous page'"),
        params: z.null(),
    }),
    z.object({
        name: z.literal('scrollDown'),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Scroll down to find the login form'"),
        params: z.null(),
    }),
    z.object({
        name: z.literal('scrollUp'),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Scroll up to find the login form'"),
        params: z.null(),
    }),
    z.object({
        name: z.literal('goToUrl'),
        params: z.object({
            url: z.string(),
        }),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Go to the login page'"),
    }),
    z.object({
        name: z.literal('takeScreenshot'),
        description: z
            .string()
            .describe("A short description of the action you want to perform. E.g 'Take a screenshot of the current page'"),
        params: z.null(),
    }),
    z
        .object({
        name: z.literal('triggerResult'),
        params: z.object({
            data: z
                .string()
                .describe('The data to be passed to the evaluator. Most likely the response to the user task.'),
        }),
        description: z.null(),
    })
        .describe('Trigger result means you have completed the task and we can ask the evaluator to evaluate the test result.'),
])
    .describe('The action to be executed. e.g. { name: "clickElement", params: { index: 2 }, description: "Click the login button" }');
const ManagerAgentResponseSchema = z.object({
    currentState: z.object({
        evaluationPreviousGoal: z.string(),
        memory: z.string(),
        nextGoal: z.string(),
    }),
    actions: z.array(ManagerAgentActionSchema),
});
const JsonifiedManagerResponseSchema = JSON.stringify(zodToJsonSchema(ManagerAgentResponseSchema, 'ExpectedResponseFormat'));
const ManagerResponseExamples = `

Example Response 1:
{
  "currentState": {
    "evaluationPreviousGoal": "Cookies have been accepted. We can now proceed to login.",
    "memory": "Cookies accepted, ready to login. End goal is to login to my account.",
    "nextGoal": "Display the login form by clicking the login button",
  },
  "actions": [{"name": "clickElement", "params": {"index": 3}, "description": "Click the login button"}]
}

Example Response 2:
{
  "currentState": {
    "evaluationPreviousGoal": "An element seems to prevent us from logging in. We need close the cookies popup.",
    "memory": "Our end goal is to login to my account. We need to close the cookies popup and then we can proceed to login.",
    "nextGoal": "Close cookies popup and then login.",
  },
  "actions": [{"name": "clickElement", "params": {"index": 5}, "description": "Close the cookies popup"}]
}

Example Response 3:
{
  "currentState": {
    "evaluationPreviousGoal": "We need to scroll down to find the login form.",
    "memory": "We need to scroll down to find the login form. End goal is to login to my account.",
    "nextGoal": "Find a recipe that has more than 100 reviews and is not Spicy Vegan Recipe"
  },
   "actions": [{"name": "scrollDown", "description": "Scroll down to find the login form"}]
}
`;

class ManagerAgentPrompt {
    constructor(maxActionPerStep) {
        this.maxActionPerStep = maxActionPerStep;
    }
    importantRules() {
        return `
  1. RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
  
  ${JsonifiedManagerResponseSchema}
  
  ${ManagerResponseExamples}
  
  2. ACTIONS: You can specify multiple actions in the list to be executed in sequence. But always specify only one action name per item.
  
     Common action sequences:
  
     // Form filling
     actions: [
        { "name": "fillInput", "params": { "index": 1, "text": "{{user_email}}" } },
        { "name": "fillInput", "params": { "index": 2, "text": "{{user_password}}" } },
        { "name": "fillInput", "params": { "index": 5, "text": "13 street name, 123456 city, country" } },
        { "name": "fillInput", "params": { "index": 6, "text": "1234567890" } },
        { "name": "scrollDown", "params": {} },
      ]
  
     // Flow that does not work
     actions: [
        { "name": "clickElement", "params": { "index": 2 } },
        { "name": "clickElement", "params": { "index": 2 } },
        { "name": "clickElement", "params": { "index": 2 } },
        { "name": "clickElement", "params": { "index": 2 } },
      ]
  
  
      "index" corresponds to the index of the element you see on the screenshot.
      Never use other indexes than the ones provided in the element list.

      Example with wrong index:
      actions: [
        { "name": "fillInput", "params": { "index": "allow all", "text": "username" } },
        { "name": "fillInput", "params": { "index": "accept", "text": "password" } },        
      ]
  
      - NEVER plan to trigger a success or failure action among other actions, you should always trigger a success or failure action alone.
      - NEVER plan to do something after a scroll action since the page will change.
      - NEVER plan to scroll down or up if there is a cookie popup or any constent popup on screen. First accept or close the popup.
      - When the page is truncated, scroll down to view more elements especially if you are filling a form.
      - Trigger result means you have completed the task and we can ask the evaluator to evaluate the test result.
      - Sometimes, the user will provide variables surrounded by double brackets {{}}. You should keep them exactly as they are, we will replace them with the actual value later.

      Wrong example (trigger success among other actions):

      actions: [
        { "name": "fillInput", "params": { "index": 1, "text": "{{user_email}}" } },
        { "name": "fillInput", "params": { "index": 2, "text": "{{user_password}}" } },
        { "name": "clickElement", "params": { "index": 2 } },
        { "name": "triggerResult", "params": { "data": "" } },
      ]

      Correct example (trigger success alone):

      actions: [
        { "name": "fillInput", "params": { "index": 1, "text": "{{user_email}}" } },
        { "name": "fillInput", "params": { "index": 2, "text": "{{user_password}}" } },
        { "name": "clickElement", "params": { "index": 2 } },
      ]

      [... later if you believe the task is completed ...]

      actions: [
        { "name": "triggerResult", "params": { "data": "The recipe named 'Vegetarian Four Cheese Lasagna' has 4.6-star, 181 reviews, Servings 8, matches your request. It is available at https://www.allrecipes.com/recipe/123456/vegetarian-four-cheese-lasagna/" } },
      ]

  3. ELEMENT INTERACTION:
     - Only use indexes that exist in the provided element list.
     - Each element has a unique index number (e.g., "[33]__<button></button>").
     - Elements with empty index "[]" are non-interactive (for context only).
     - DO NOT try to fill an input field you already filled it with a value.   
  
  4. **NAVIGATION & ERROR HANDLING:**
   - **Track failed actions** and **do not repeat the same mistake**.
   - **Never enter a loop** where the same action fails repeatedly.
   - Example of a failure loop history (❌ Incorrect - must be avoided):

    -------
    "Scroll up to find the star rating and verify if zucchini is included in the ingredients.",
    "Scroll up to find the star rating and verify if zucchini is included in the ingredients.",
    "Scroll down to find the star rating and ingredients list.",
    "Scroll down to find the star rating and ingredients list.",
    "Search for another vegetarian lasagna recipe with zucchini and at least a four-star rating."
    -------
    
   - If an evaluator **rejects your result**, you **must adjust your approach** instead of retrying blindly.
   - **Before retrying, ask yourself:**
     - Did I already try this exact action?
     - Is there an alternative approach I can take?
     - Can I gather more information before acting?

  5. SCROLLING BEHAVIOR:
     - **Never plan to scroll if there is a popup (cookies, modals, alerts, etc.).**
     - **After scrolling, always verify progress** before scrolling again.
     - **Avoid infinite scrolling loops.**
     
  6. TASK COMPLETION:
     - When you evaluate the task, you shouls always ask yourself if the Success condition given by the user is met. If it is, use the triggerResult action as the last action.
     - If you are running out of steps (current step), think about speeding it up, and ALWAYS use the triggerResult action as the last action.
  
  7. VISUAL CONTEXT:
     - When an image is provided, use it to understand the page layout.
     - Bounding boxes with labels correspond to element indexes.
     - Each bounding box and its label have the same color.
     - Most often the label is inside the bounding box, on the top right.
     - Visual context helps verify element locations and relationships.
     - Sometimes labels overlap, so use the context to verify the correct element.
     - Sometimes it's easier to extract the information from the content of the page than from the visual context (especially when you are dealing with a list of products). To do this, use the extractContent action.
  
  8. FORM FILLING:
     - If you fill an input field and your action sequence is interrupted, most often a list with suggestions popped up under the field and you need to first select the right element from the suggestion list.
     - Sometimes when filling a date field, a calendar poup is displayed which can make the action sequence interrupted so you need to first select the right date from the calendar.
     - If you fill an input field and you see it's still empty, you need to fill it again.
  
  9. ACTION SEQUENCING:
     - Actions are executed in the order they appear in the list.
     - Each action should logically follow from the previous one.
     - Only provide the action sequence until you think the page will change.
     - Try to be efficient, e.g. fill forms at once, or chain actions where nothing changes on the page like saving, extracting, checkboxes...
     - only use multiple actions if it makes sense.
     - After you have scrolled down or up, you should always ask yourself if you achieved your goal. If not, you should scroll down or up again.
     - When you will define the next goal, make sure to be as specific as possible to avoid misleading the agent. Ask yourself the following questions:
       - Does my goal go against the constraints of my end goal?
       - Does my goal do something that has been done multiple times (loop)?
       - Does my goal go against my memory learning?
       - Did I already try this action or got this information in my memory learning?
       -> Reajust your goal if needed.


    10. RESULT:
      - You should always provide a result in the triggerResult action.
      - The result should be a string that describes the result of the task and matches the user's goal or question.
      - DO NOT hallucinate the result.
      - Your result should ALWAYS be based on what you see, or what you extract from the content of the page and not on what you think you know.
      - When you will trigger the result, pay attention to the feedback you will receive. This feedback will contain the reason why the task failed and the hint to fix it. It is paramount to you to follow the hint.
  
      Use a maximum of ${this.maxActionPerStep} actions per task.
  `;
    }
    inputFormat() {
        return `
      INPUT STRUCTURE:
      1. MEMORY LEARNINGS: A list of memory learning you should know about your previous actions. This will prevent you from doing the same mistakes over and over again. This can be used also to store information you have extracted in the past.
      2. CURRENT URL: The webpage you're currently on.
      3. EXTRACTED DOM ELEMENTS: List in the format:
        [index]__<element_type attributes=value>element_text</element_type>
        - index: Numeric identifier for interaction (if empty, the element is non-interactive).
        - element_type: HTML element type (button, input, select, etc.).
        - element_text: Visible text or element description.
        - attributes: HTML attributes of the element used for context.
        
      4. TASK: The task asked by the user. 
        - Use it to define the actions you have to perform.
        - No failure is tolerated and success is rewarded.
        - You must be sure of the data you provide. Make sure to provide the exact data. Open products and navigate until you find the information you need.
        - It's better to navigate a bit more than to provide wrong information.
  
      Notes:
      - Only elements with numeric indexes are interactive.
      - Elements with empty index [] provide context but cannot be interacted with.
  
      Interactive examples:
      [14]__<button id="submit-btn">Submit Form</button>
      [15]__<input type="text" placeholder="Enter your name" for="name">
  
      Non-interactive examples:
      []__<div>Non interactive div</div>
      []__<span>Non interactive span</span>
      []__Non interactive text
      `;
    }
    getSystemPrompt() {
        return `
      You are a precise Browser Automation Agent that interacts with websites through structured commands. Your role is to:
  
      1. Analyze the provided webpage elements and structure.
      2. Plan a sequence of actions to achieve the task provided by the user.
      3. Respond with valid JSON containing your action sequence.
      4. When you consider the scenario is complete and we can evaluate the test result, use the triggerSuccess to pass some data to the evaluator.
  
      Current date and time: ${new Date().toISOString()}
  
      ${this.inputFormat()}
  
      ${this.importantRules()}
  
      Functions:
      - clickElement: { index: <element_index> }
      - fillInput: { index: <element_index>, text: <text> }
      - scrollDown: { goal: <goal> }
      - scrollUp: { goal: <goal> }
      - goToUrl: { url: <url> }    
      - triggerResult: { data: <data> }
      - goBack: {}
      - extractContent: {}
  
      Remember: Your responses must be valid JSON matching the specified format. Each action in the sequence must be valid."""
  `;
    }
    getSystemMessage() {
        return new SystemMessage({
            content: this.getSystemPrompt(),
        });
    }
}
class ManagerAgentHumanPrompt {
    constructor() { }
    getHumanMessage({ memoryLearnings, serializedTasks, stringifiedDomState, screenshotUrl, pristineScreenshotUrl, pageUrl, pixelAbove, pixelBelow, }) {
        return new HumanMessage({
            content: [
                {
                    type: 'image_url',
                    image_url: {
                        url: pristineScreenshotUrl,
                        detail: 'high',
                    },
                },
                {
                    type: 'image_url',
                    image_url: {
                        url: screenshotUrl,
                        detail: 'high',
                    },
                },
                {
                    type: 'text',
                    text: `
          MEMORY LEARNINGS: ${memoryLearnings}

          CURRENT URL: ${pageUrl}

          ... ${pixelAbove} PIXEL ABOVE - SCROLL UP TO SEE MORE ELEMENTS

          EXTRACTED DOM ELEMENTS: ${stringifiedDomState} that you can match with the screenshot.

          ... ${pixelBelow} PIXEL BELOW - SCROLL DOWN TO SEE MORE ELEMENTS

          USER TASK AND TASK HISTORY: ${serializedTasks}
          `,
                },
            ],
        });
    }
}

const DEFAULT_AGENT_MAX_RETRIES = 3;
const DEFAULT_AGENT_MAX_ACTIONS_PER_TASK = 4;

class TaskAction {
    constructor(data) {
        this.data = data;
        this.id = crypto$1.randomUUID();
        this._status = 'pending';
        this.data = data;
        this.result = '';
    }
    get status() {
        return this._status;
    }
    start() {
        this._status = 'running';
    }
    complete(result) {
        this._status = 'completed';
        this.result = result ?? 'ok';
    }
    cancel(reason) {
        this._status = 'cancelled';
        this._reason = reason;
    }
    fail(reason) {
        this._status = 'failed';
        this._reason = reason;
        this.result = `Action failed with reason: ${reason}`;
    }
    asObject() {
        return {
            id: this.id,
            status: this.status,
            reason: this._reason,
            name: this.data.name,
            params: this.data.params,
            description: this.data.description,
        };
    }
    objectForLLM() {
        return {
            description: this.data.description,
            status: this.status,
            result: this.result,
            reason: this._reason,
        };
    }
}
class Task {
    constructor(id, goal, actions, _status, _reason = undefined) {
        this.id = id;
        this.goal = goal;
        this.actions = actions;
        this._status = _status;
        this._reason = _reason;
    }
    static InitPending(goal, actions) {
        const taskActions = actions.map((action) => new TaskAction(action));
        return new Task(crypto$1.randomUUID(), goal, taskActions ?? [], 'pending');
    }
    get status() {
        return this._status;
    }
    get reason() {
        return this._reason;
    }
    get pendingActions() {
        return this.actions.filter((action) => action.status === 'pending');
    }
    get nextPendingAction() {
        return this.pendingActions[0] ?? null;
    }
    completeAction(id) {
        const action = this.actions.find((action) => action.id === id);
        if (!action) {
            throw new Error('Action not found');
        }
        action.complete();
        if (!this.pendingActions.length) {
            action.complete();
        }
        if (!this.pendingActions.length) {
            this.complete();
        }
    }
    cancelAction(id, reason) {
        const action = this.actions.find((action) => action.id === id);
        if (!action) {
            throw new Error('Action not found');
        }
        action.cancel(reason);
        this.cancel(reason);
    }
    start() {
        this._status = 'running';
    }
    complete() {
        this._status = 'completed';
    }
    cancel(reason) {
        this._status = 'cancelled';
        this._reason = reason;
    }
    fail(reason) {
        this._status = 'failed';
        this._reason = reason;
    }
    objectForLLM() {
        return {
            goal: this.goal,
            actionsTaken: this.actions.map((action) => action.objectForLLM()),
        };
    }
    serialize() {
        return JSON.stringify({
            id: this.id,
            goal: this.goal,
            actions: this.actions.map((action) => action.asObject()),
            status: this.status,
            reason: this.reason,
        });
    }
    asObject() {
        return {
            id: this.id,
            goal: this.goal,
            actions: this.actions.map((action) => action.asObject()),
            status: this.status,
            reason: this.reason,
        };
    }
}

class VariableString {
    constructor(_value, variables) {
        this._value = _value;
        this.variables = variables;
    }
    publicValue() {
        let interpolatedValue = this._value;
        const variablePattern = /{{(.*?)}}/g;
        interpolatedValue = interpolatedValue.replace(variablePattern, (_, varName) => {
            const variable = this.variables.find((v) => v.name === varName);
            return variable ? variable.publicValue() : `{{${varName}}}`;
        });
        return interpolatedValue;
    }
    dangerousValue() {
        let interpolatedValue = this._value;
        const variablePattern = /{{(.*?)}}/g;
        interpolatedValue = interpolatedValue.replace(variablePattern, (_, varName) => {
            const variable = this.variables.find((v) => v.name === varName);
            return variable ? variable.dangerousValue() : `{{${varName}}}`;
        });
        return interpolatedValue;
    }
}

class Run {
    constructor(scenario, jobId) {
        this.scenario = scenario;
        this.id = jobId || crypto.randomUUID();
        this._status = 'running';
        this._tasks = [];
        this._brainState = 'thinking';
        this._resultReason = '';
        this._result = '';
    }
    get status() {
        return this._status;
    }
    get tasks() {
        return this._tasks;
    }
    get brainState() {
        return this._brainState;
    }
    get resultReason() {
        return this._resultReason;
    }
    get result() {
        return this._result;
    }
    static InitRunning(scenario, jobId) {
        return new Run(scenario, jobId);
    }
    think() {
        this._brainState = 'thinking';
    }
    executeAction() {
        this._brainState = 'executingAction';
    }
    retry() {
        this._retries += 1;
    }
    run() {
        this._status = 'running';
    }
    addTask(task) {
        this._tasks.push(task);
    }
    updateTask(task) {
        this._tasks = this._tasks.map((t) => (t.id === task.id ? task : t));
    }
    setSuccess(answer) {
        this._status = 'completed';
        this._result = answer;
    }
    setFailure(reason) {
        this._status = 'failed';
        this._resultReason = reason;
    }
}

class Openator {
    constructor(config) {
        this.msDelayBetweenActions = 1000;
        this.lastDomStateHash = null;
        this.isSuccess = false;
        this.isFailure = false;
        this.reason = '';
        this.result = '';
        this.retries = 0;
        this.stepCount = 0;
        this.feedbackRetries = 0;
        this.currentRun = null;
        this.memoryLearnings = [];
        this.taskManager = config.taskManager;
        this.domService = config.domService;
        this.browserService = config.browserService;
        this.llmService = config.llmService;
        this.reporter = config.reporter;
        this.variables = config.variables;
        this.feedbackAgent = config.feedbackAgent;
        this.memoryLearnings = [];
        this.maxActionsPerTask =
            config.maxActionsPerTask ?? DEFAULT_AGENT_MAX_ACTIONS_PER_TASK;
        this.maxRetries = config.maxRetries ?? DEFAULT_AGENT_MAX_RETRIES;
        this.eventBus = config.eventBus;
        this.summarizer = config.summarizer;
        this.summarizeTask = config.summarizeTask;
    }
    onSuccess(result) {
        this.reporter.success(`Manager agent completed successfully: ${result}`);
        this.isSuccess = true;
        this.result = result;
        this.currentRun.setSuccess(result);
        this.emitRunUpdate();
    }
    onFailure(reason) {
        this.reporter.failure(`Manager agent failed: ${reason}`);
        this.isFailure = true;
        this.reason = reason;
        this.currentRun.setFailure(reason);
        this.emitRunUpdate();
    }
    async beforeAction(action) {
        this.reporter.loading(`Performing action ${action.data.name}...`);
    }
    async afterAction(action) {
        this.reporter.success(`Performing action ${action.data.name}...`);
    }
    async incrementFeedbackRetries() {
        this.feedbackRetries += 1;
    }
    async incrementRetries() {
        this.retries += 1;
    }
    async resetRetries() {
        this.retries = 0;
    }
    async incrementStepCount() {
        this.stepCount += 1;
    }
    get isCompleted() {
        return this.isSuccess || this.isFailure;
    }
    async start(startUrl, initialPrompt, jobId) {
        const vStartUrl = new VariableString(startUrl, this.variables);
        await this.browserService.launch(vStartUrl.dangerousValue());
        const vInitialPrompt = new VariableString(initialPrompt, this.variables);
        this.taskManager.setEndGoal(vInitialPrompt.publicValue());
        return this.run(jobId);
    }
    async emitRunUpdate() {
        this.eventBus?.emit('run:update', this.currentRun);
    }
    async run(jobId) {
        return new Promise(async (resolve) => {
            this.reporter.loading('Starting manager agent');
            this.currentRun = Run.InitRunning(this.taskManager.getEndGoal(), jobId);
            this.emitRunUpdate();
            while (!this.isCompleted) {
                if (this.retries >= this.maxRetries) {
                    this.onFailure('Max retries reached');
                    return resolve({
                        status: 'failed',
                        result: this.result,
                        stepCount: this.stepCount,
                        reason: 'Max number of retried reached. The agent was not able to complete the test.',
                    });
                }
                this.incrementStepCount();
                this.reporter.loading('Defining next task...');
                const task = await this.defineNextTask();
                this.currentRun.addTask(task);
                this.currentRun.executeAction();
                this.emitRunUpdate();
                this.reporter.loading(`Executing task: ${task.goal}`);
                await this.executeTask(task);
            }
            if (this.isFailure) {
                this.currentRun.setFailure(this.reason);
                this.emitRunUpdate();
                return resolve({
                    status: 'failed',
                    reason: this.reason,
                    result: this.result,
                    stepCount: this.stepCount,
                });
            }
            await this.domService.resetHighlightElements();
            this.emitRunUpdate();
            return resolve({
                status: this.isSuccess ? 'success' : 'failed',
                reason: this.reason,
                result: this.result,
                stepCount: this.stepCount,
            });
        });
    }
    async didDomStateChange() {
        const { domStateHash: currentDomStateHash } = await this.domService.getInteractiveElements(false);
        return this.lastDomStateHash !== currentDomStateHash;
    }
    ensureNoTriggerSuccessOrFailureAmongOtherActions(actions) {
        if (actions.length < 2) {
            return actions;
        }
        return actions.filter((action) => action.name !== 'triggerResult');
    }
    async defineNextTask() {
        this.currentRun.think();
        this.emitRunUpdate();
        const parser = new JsonOutputParser();
        const systemMessage = new ManagerAgentPrompt(this.maxActionsPerTask).getSystemMessage();
        const { screenshot, pristineScreenshot, stringifiedDomState, domStateHash, pixelAbove, pixelBelow, } = await this.domService.getInteractiveElements();
        this.lastDomStateHash = domStateHash;
        const humanMessage = new ManagerAgentHumanPrompt().getHumanMessage({
            memoryLearnings: this.memoryLearnings.join(' ; '),
            serializedTasks: this.taskManager.getSerializedTasks(),
            pristineScreenshotUrl: pristineScreenshot,
            screenshotUrl: screenshot,
            stringifiedDomState,
            pageUrl: this.browserService.getPageUrl(),
            pixelAbove,
            pixelBelow,
        });
        const messages = [systemMessage, humanMessage];
        try {
            const parsedResponse = await this.llmService.invokeAndParse(messages, parser);
            const safeActions = this.ensureNoTriggerSuccessOrFailureAmongOtherActions(parsedResponse.actions);
            const task = Task.InitPending(parsedResponse.currentState.nextGoal, safeActions);
            this.taskManager.add(task);
            return task;
        }
        catch (error) {
            console.error('Error parsing agent response:', error);
            return Task.InitPending('Keep trying', []);
        }
    }
    async executeTask(task) {
        task.start();
        await this.domService.resetHighlightElements();
        for (const [i, action] of task.actions.entries()) {
            try {
                action.start();
                this.emitRunUpdate();
                if (i > 0 && (await this.didDomStateChange())) {
                    action.cancel('Dom state changed, need to reevaluate.');
                    task.cancel('Dom state changed, need to reevaluate.');
                    this.taskManager.update(task);
                    this.reporter.info('Dom state changed, need to reevaluate.');
                    return;
                }
                await this.executeAction(action);
                this.emitRunUpdate();
                await new Promise((resolve) => setTimeout(resolve, this.msDelayBetweenActions));
                task.complete();
                this.emitRunUpdate();
                this.resetRetries();
                this.taskManager.update(task);
            }
            catch (error) {
                action.fail(`Task failed with error: ${error?.message ?? 'Unknown error'}`);
                task.fail(`Task failed with error: ${error?.message ?? 'Unknown error'}`);
                this.taskManager.update(task);
                this.incrementRetries();
                this.emitRunUpdate();
            }
        }
        this.reporter.success(task.goal);
    }
    async executeAction(action) {
        let coordinates = null;
        await this.beforeAction(action);
        this.emitRunUpdate();
        switch (action.data.name) {
            case 'clickElement':
                coordinates = this.domService.getIndexSelector(action.data.params.index);
                if (!coordinates) {
                    throw new Error('Index or coordinates not found');
                }
                await this.domService.resetHighlightElements();
                await this.domService.highlightElementPointer(coordinates);
                await this.browserService.mouseClick(coordinates.x, coordinates.y);
                await this.domService.resetHighlightElements();
                action.complete();
                break;
            case 'fillInput':
                coordinates = this.domService.getIndexSelector(action.data.params.index);
                if (!coordinates) {
                    action.fail('Index or coordinates not found');
                    throw new Error('Index or coordinates not found');
                }
                await this.domService.highlightElementPointer(coordinates);
                const variableString = new VariableString(action.data.params.text, this.variables);
                await this.browserService.fillInput(variableString, coordinates);
                await this.domService.resetHighlightElements();
                action.complete();
                break;
            case 'scrollDown':
                await this.browserService.scrollDown();
                await this.domService.resetHighlightElements();
                await this.domService.highlightElementWheel('down');
                action.complete();
                break;
            case 'scrollUp':
                await this.browserService.scrollUp();
                await this.domService.resetHighlightElements();
                await this.domService.highlightElementWheel('up');
                action.complete();
                break;
            case 'takeScreenshot':
                await this.domService.resetHighlightElements();
                await this.domService.highlightForSoM();
                action.complete();
                break;
            case 'goToUrl':
                await this.browserService.goToUrl(action.data.params.url);
                action.complete();
                break;
            case 'goBack':
                await this.browserService.goBack();
                action.complete();
                break;
            case 'extractContent':
                const content = await this.browserService.extractContent();
                this.summarizeTask.prepare({
                    images: [],
                    memory: '',
                    input: `Our goal is to ${this.taskManager.getEndGoal()} Here is the content extracted from the page: ${content}.`,
                });
                const summarized = await this.summarizer.perform(this.summarizeTask);
                this.memoryLearnings.push(`Key takeways from content on page ${this.browserService.getPageUrl()}: ${summarized.takeaways}`);
                action.complete(summarized.takeaways);
                console.log('-----this.memoryLearnings', this.memoryLearnings);
                break;
            case 'triggerResult':
                const { pristineScreenshot } = await this.domService.getDomState();
                const answer = action.data.params.data;
                const { result, explanation, hint, memoryLearning } = await this.feedbackAgent.evaluate({
                    pageUrl: this.browserService.getPageUrl(),
                    screenshotUrls: [pristineScreenshot],
                    task: this.taskManager.getEndGoal(),
                    answer,
                    taskHistorySummary: this.taskManager.getSerializedTasks(),
                    previousTaskResult: JSON.stringify(this.taskManager.getLatestTaskPerformed()?.objectForLLM()),
                });
                if (result === 'success' || result === 'unknown') {
                    action.complete(explanation);
                    this.onSuccess(answer);
                }
                else {
                    if (this.feedbackRetries > this.maxRetries) {
                        this.onFailure('Max feedback retries reached');
                    }
                    action.fail(JSON.stringify({ result, explanation, hint }));
                    this.memoryLearnings.push(memoryLearning);
                    this.incrementFeedbackRetries();
                }
                break;
        }
        await this.afterAction(action);
        this.emitRunUpdate();
    }
}

class Agent {
    constructor(config) {
        this.config = config;
        this.backstory = config.backstory;
        this.goal = config.goal;
        this.tools = config.tools;
        this.role = config.role;
        this.strictJsonOutput = config.strictJsonOutput;
        this.responseSchema = config.responseSchema;
    }
    getSystemPrompt() {
        return `
      You are a ${this.role}

      ${this.backstory}

      ${this.goal}

      ${this.tools}

      ${this.strictJsonOutput ? 'IMPORTANT: your output must always be a valid JSON object.' : ''}
    `;
    }
    getUserTaskPrompt(task) {
        return task.getTaskPrompt();
    }
    getSystemMessage() {
        return new SystemMessage({
            content: this.getSystemPrompt(),
        });
    }
    getHumanMessage(task) {
        return new HumanMessage({
            content: [
                {
                    role: 'user',
                    type: 'text',
                    text: this.getUserTaskPrompt(task),
                },
            ],
        });
    }
    async perform(task) {
        const messages = [this.getSystemMessage(), this.getHumanMessage(task)];
        const parser = new JsonOutputParser();
        const response = await this.config.llm.invokeAndParse(messages, parser);
        return response;
    }
}
class AgentTask {
    constructor(config) {
        this.config = config;
    }
    prepare(params) {
        this.input = params.input;
        this.images = params.images;
        this.memory = params.memory;
    }
    getTaskPrompt() {
        return `    
      # Task description:
      ${this.config.description}

      # Task goal:
      ${this.config.goal}

      # Expected output:
      ${this.config.expectedOutput}

      # Example valid outputs:
      ${this.config.validOutputExamples};

      # Example invalid outputs:
      ${this.config.invalidOutputExamples}

      # Images:
      ${this.images} at the end

      # Memory:
      ${this.memory}

      # User input:
      ${this.input}
    `;
    }
    getTaskMessages() {
        const images = this.images.map((image) => {
            return {
                type: 'image_url',
                image_url: {
                    url: image,
                },
            };
        });
        return [
            new HumanMessage({
                content: [
                    {
                        type: 'text',
                        text: this.getTaskPrompt(),
                    },
                    ...images,
                ],
            }),
        ];
    }
}

const responseSchema = z.object({
    takeaways: z.string(),
});
const initSummarizer = (openAiApiKey, llm) => new Agent({
    role: 'Summarizer',
    goal: 'Summarize the content provided by the user with key takeaways',
    backstory: `You are a meticulous analyst with a keen eye for detail.

  You are able to summarize the content provided by the user with key takeaways.

  Depending on the context, you will deduce that details are not relevant to the users.

  These details will depends on the context of the user.

  For example, in a recipe website, the list of ingredients, calories, etc. are relevant to the user. Where as in a news website, the list of ingredients, calories, etc. are not relevant to the user.
    `,
    tools: [],
    strictJsonOutput: true,
    llm,
    responseSchema,
});
const initSummarizeTask = () => new AgentTask({
    description: 'Summarize the key takeaways from the content provided by the user. Try to use the least amount of words possible without losing the context. Be as specific as possible.',
    goal: 'The goal is to summarize the content provided by the user with key takeaways.',
    expectedOutput: 'A JSON object with the following properties: { takeaways: string[] }',
    validOutputExamples: `{ "takeaways": "The recipie named Vegetarian Lasagna is available at https://www.example.com/recipes/vegetarian-lasagna", has a rating of 4.4, contains zuchini, tomatoes, cucumber, and under 500 calories per serving. }`,
    invalidOutputExamples: `{ "takeaways": "The recipie named Vegetarian Lasagna is good" }`,
});

class EventBus extends EventEmitter {
    emit(event, data) {
        return super.emit(event, data);
    }
    on(event, callback) {
        return super.on(event, callback);
    }
}

class TaskManagerService {
    constructor() {
        this.tasks = [];
        this.endGoal = null;
    }
    setEndGoal(endGoal) {
        this.endGoal = endGoal;
    }
    getEndGoal() {
        return this.endGoal;
    }
    add(task) {
        this.tasks.push(task);
    }
    update(task) {
        this.tasks = this.tasks.map((t) => (t.id === task.id ? task : t));
    }
    getLatestTaskPerformed() {
        return (this.tasks.filter((t) => t.status !== 'running')[this.tasks.length - 1] ??
            null);
    }
    getTaskHistorySummary() {
        return this.tasks.map((t) => t.goal);
    }
    getSerializedTasks() {
        const serialized = JSON.stringify({
            endGoal: this.endGoal,
            taskHistorySummary: this.getTaskHistorySummary(),
            previousTaskResult: this.getLatestTaskPerformed()?.objectForLLM(),
        }, null, 2);
        console.log('serialized', serialized);
        return serialized;
    }
}

class ChromiumBrowser {
    constructor(options) {
        this.options = options;
        this.page = null;
        this.context = null;
        this.minimumPageLoadTime = 400;
    }
    async launch(url) {
        const wsEndpoint = this.options?.wsEndpoint ?? process.env.PLAYWRIGHT_WS_ENDPOINT ?? null;
        let browser;
        if (wsEndpoint) {
            browser = await chromium.connectOverCDP(wsEndpoint);
        }
        else {
            browser = await chromium.launch({
                headless: this.options.headless,
            });
        }
        this.context = await browser.newContext({
            screen: {
                width: 1440,
                height: 900,
            },
            viewport: {
                width: 1440,
                height: 900,
            },
        });
        this.page = await this.context.newPage();
        await this.page.goto(url);
    }
    async waitForDomContentLoaded() {
        await this.getPage().waitForLoadState('domcontentloaded');
    }
    async waitMinimumPageLoadTime() {
        return new Promise((resolve) => setTimeout(resolve, this.minimumPageLoadTime));
    }
    async waitForStability() {
        return Promise.all([
            this.waitForDomContentLoaded(),
            this.waitMinimumPageLoadTime(),
        ]);
    }
    async getStablePage() {
        await this.waitForStability();
        return this.getPage();
    }
    async close() {
        if (this.context) {
            this.context.close();
        }
    }
    getPage() {
        if (!this.page) {
            throw new Error('The page is not initialized or has been detroyed.');
        }
        return this.page;
    }
    getPageUrl() {
        return this.getPage().url();
    }
    async mouseClick(x, y) {
        await Promise.all([
            this.getPage().mouse.click(x, y),
            this.getPage().waitForLoadState('domcontentloaded'),
        ]);
    }
    async getPixelAbove() {
        return this.getPage().evaluate(() => {
            return window.scrollY;
        });
    }
    async getPixelBelow() {
        return this.getPage().evaluate(() => {
            return window.scrollY + window.innerHeight;
        });
    }
    async fillInput(text, coordinates) {
        await this.getPage().mouse.click(coordinates.x, coordinates.y);
        await this.getPage().keyboard.press('ControlOrMeta+A');
        await this.getPage().keyboard.press('Backspace');
        await this.getPage().keyboard.type(text.dangerousValue(), { delay: 100 });
    }
    async scrollDown() {
        await this.getPage().mouse.wheel(0, 500);
        await this.getPage().waitForTimeout(300);
    }
    async scrollUp() {
        await this.getPage().mouse.wheel(0, -500);
        await this.getPage().waitForTimeout(300);
    }
    async goToUrl(url) {
        await this.getPage().goto(url);
    }
    async goBack() {
        await this.getPage().goBack();
    }
    async extractContent() {
        const html = await this.getPage().content();
        const dom = new JSDOM(html);
        const markdown = convertHtmlToMarkdown(html, {
            overrideDOMParser: new dom.window.DOMParser(),
            extractMainContent: true,
        });
        return markdown;
    }
}

class ConsoleReporter {
    constructor(name) {
        this.name = name;
    }
    getSpinner() { }
    success(message) {
        console.log(`[${this.name}] ✅ ${message}`);
    }
    failure(message) {
        console.log(`[${this.name}] ❌ ${message}`);
    }
    loading(message) {
        console.log(`[${this.name}] 💡 ${message}`);
    }
    info(message) {
        console.log(`[${this.name}] 💡 ${message}`);
    }
}

const isElementNode = (node) => {
    if (!node)
        return false;
    return !('type' in node) || node.type !== 'TEXT_NODE';
};
const IMPORTANT_ATTRIBUTES = [
    'id',
    'name',
    'value',
    'placeholder',
    'aria-label',
    'role',
    'for',
    'href',
    'alt',
    'title',
    'data-testid',
    'data-test',
    'data-test-id',
    'data-test-name',
    'data-test-value',
];
const isTextNode = (node) => {
    return 'type' in node && node.type === 'TEXT_NODE';
};
class DomService {
    constructor(screenshotService, browserService, eventBus) {
        this.screenshotService = screenshotService;
        this.browserService = browserService;
        this.eventBus = eventBus;
        this.domContext = {
            selectorMap: {},
        };
    }
    stringifyDomStateForHash(nodeState) {
        const items = [];
        const format = (node) => {
            if (!isElementNode(node)) {
                return;
            }
            if (node.highlightIndex) {
                const str = `[${node.isInteractive ? node.highlightIndex : ''}]__<${node.tagName}>`;
                items.push(str);
            }
            for (const child of node.children) {
                if (child) {
                    format(child);
                }
            }
        };
        format(nodeState);
        return items.join('\n');
    }
    hashDomState(domState) {
        if (!domState) {
            return '';
        }
        const domStateString = this.stringifyDomStateForHash(domState);
        return crypto$1.createHash('sha256').update(domStateString).digest('hex');
    }
    getIndexSelector(index) {
        const domNode = this.domContext?.selectorMap[index];
        if (!domNode) {
            return null;
        }
        if (isTextNode(domNode)) {
            return null;
        }
        return domNode.coordinates;
    }
    async getDomState(withHighlight = true) {
        await this.resetHighlightElements();
        const pristineScreenshot = await this.screenshotService.takeScreenshot(await this.browserService.getStablePage());
        this.eventBus.emit('pristine-screenshot:taken', pristineScreenshot);
        const state = await this.highlightForSoM(withHighlight);
        const screenshot = await this.screenshotService.takeScreenshot(await this.browserService.getStablePage());
        const pixelAbove = await this.browserService.getPixelAbove();
        const pixelBelow = await this.browserService.getPixelBelow();
        return {
            screenshot,
            pristineScreenshot,
            domState: state,
            pixelAbove,
            pixelBelow,
        };
    }
    async getInteractiveElements(withHighlight = true) {
        const { screenshot, pristineScreenshot, domState, pixelAbove, pixelBelow } = await this.getDomState(withHighlight);
        const selectorMap = this.createSelectorMap(domState);
        const stringifiedDomState = this.stringifyDomState(domState);
        const domStateHash = this.hashDomState(domState);
        this.domContext.selectorMap = selectorMap;
        return {
            screenshot,
            pristineScreenshot,
            domState,
            selectorMap,
            stringifiedDomState,
            domStateHash,
            pixelAbove,
            pixelBelow,
        };
    }
    createSelectorMap(nodeState) {
        const selectorMap = {};
        const mapNode = (node) => {
            if (isElementNode(node)) {
                selectorMap[node.highlightIndex] = node;
                for (const child of node.children) {
                    mapNode(child);
                }
            }
        };
        mapNode(nodeState);
        return selectorMap;
    }
    stringifyDomState(nodeState) {
        const items = [];
        const format = (node) => {
            if (!isElementNode(node)) {
                return;
            }
            const attributes = Object.entries(node.attributes)
                .filter(([key]) => IMPORTANT_ATTRIBUTES.includes(key))
                .map(([key, value]) => `${key}="${value}"`)
                .join(' ');
            if (node.highlightIndex) {
                const str = `[${node.isInteractive ? node.highlightIndex : ''}]__<${node.tagName} ${attributes}>${node.text}</${node.tagName}>`;
                items.push(str);
            }
            for (const child of node.children) {
                if (child) {
                    format(child);
                }
            }
        };
        format(nodeState);
        return items.join('\n');
    }
    async resetHighlightElements() {
        const page = await this.browserService.getStablePage();
        await page.evaluate(() => {
            try {
                const container = document.getElementById('playwright-highlight-container');
                if (container) {
                    container.remove();
                }
                const highlightedElements = document.querySelectorAll('[magic-inspector-highlight-id^="playwright-highlight-"]');
                highlightedElements.forEach((el) => {
                    el.removeAttribute('magic-inspector-highlight-id');
                });
            }
            catch (e) {
                console.error('Failed to remove highlights:', e);
            }
        });
    }
    async highlightElementWheel(direction) {
        const page = await this.browserService.getStablePage();
        await page.evaluate((direction) => {
            console.log('highlightElementWheel', direction);
        }, direction);
    }
    async highlightElementPointer(coordinates) {
        const page = await this.browserService.getStablePage();
        await page.evaluate((coordinates) => {
            try {
                let container = document.getElementById('playwright-pointer-highlight-container');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'playwright-pointer-highlight-container';
                    container.style.position = 'fixed';
                    container.style.pointerEvents = 'none';
                    container.style.top = '0';
                    container.style.left = '0';
                    container.style.width = '100%';
                    container.style.height = '100%';
                    container.style.zIndex = '2147483647';
                    document.body.appendChild(container);
                }
                const circle = document.createElement('div');
                circle.style.position = 'absolute';
                circle.style.width = '20px';
                circle.style.height = '20px';
                circle.style.borderRadius = '50%';
                circle.style.backgroundColor = 'red';
                circle.style.left = `${coordinates.x - 10}px`;
                circle.style.top = `${coordinates.y - 10}px`;
                circle.style.pointerEvents = 'none';
                container.appendChild(circle);
                setTimeout(() => {
                    circle.remove();
                    container.remove();
                }, 2000);
            }
            catch (e) {
                console.error('Failed to draw highlight circle:', e);
            }
        }, coordinates);
    }
    async waitForStability(page) {
        await page.waitForTimeout(1500);
    }
    async highlightForSoM(withHighlight = true) {
        try {
            const page = await this.browserService.getStablePage();
            if (page.isClosed()) {
                return null;
            }
            await this.waitForStability(page);
            const domState = await page.evaluate((withHighlight) => {
                const doHighlightElements = true;
                const focusHighlightIndex = -1;
                const viewportExpansion = 0;
                let highlightIndex = 0;
                function highlightElement(element, index, parentIframe = null) {
                    if (!withHighlight) {
                        return;
                    }
                    let container = document.getElementById('playwright-highlight-container');
                    if (!container) {
                        container = document.createElement('div');
                        container.id = 'playwright-highlight-container';
                        container.style.position = 'absolute';
                        container.style.pointerEvents = 'none';
                        container.style.top = '0';
                        container.style.left = '0';
                        container.style.width = '100%';
                        container.style.height = '100%';
                        container.style.zIndex = '2147483647';
                        document.body.appendChild(container);
                    }
                    const colors = [
                        '#FF0000',
                        '#00FF00',
                        '#0000FF',
                        '#FFA500',
                        '#800080',
                        '#008080',
                        '#FF69B4',
                        '#4B0082',
                        '#FF4500',
                        '#2E8B57',
                        '#DC143C',
                        '#4682B4',
                    ];
                    const colorIndex = index % colors.length;
                    const baseColor = colors[colorIndex];
                    const backgroundColor = `${baseColor}1A`;
                    const overlay = document.createElement('div');
                    overlay.style.position = 'absolute';
                    overlay.style.border = `2px solid ${baseColor}`;
                    overlay.style.backgroundColor = backgroundColor;
                    overlay.style.pointerEvents = 'none';
                    overlay.style.boxSizing = 'border-box';
                    const rect = element.getBoundingClientRect();
                    let top = rect.top + window.scrollY;
                    let left = rect.left + window.scrollX;
                    if (parentIframe) {
                        const iframeRect = parentIframe.getBoundingClientRect();
                        top += iframeRect.top;
                        left += iframeRect.left;
                    }
                    overlay.style.top = `${top}px`;
                    overlay.style.left = `${left}px`;
                    overlay.style.width = `${rect.width}px`;
                    overlay.style.height = `${rect.height}px`;
                    const label = document.createElement('div');
                    label.className = 'playwright-highlight-label';
                    label.style.position = 'absolute';
                    label.style.background = `${baseColor}`;
                    label.style.color = 'white';
                    label.style.padding = '1px 4px';
                    label.style.borderRadius = '4px';
                    label.style.fontSize = `${Math.min(12, Math.max(8, rect.height / 2))}px`;
                    label.textContent = `[${index}]`;
                    const labelWidth = 20;
                    const labelHeight = 16;
                    let labelTop = top + 2;
                    let labelLeft = left + rect.width - labelWidth - 2;
                    if (rect.width < labelWidth + 4 || rect.height < labelHeight + 4) {
                        labelTop = top - labelHeight - 2;
                        labelLeft = left + rect.width - labelWidth;
                    }
                    label.style.top = `${labelTop}px`;
                    label.style.left = `${labelLeft}px`;
                    container.appendChild(overlay);
                    container.appendChild(label);
                    element.setAttribute('magic-inspector-highlight-id', `playwright-highlight-${index}`);
                    return index + 1;
                }
                function getXPathTree(element, stopAtBoundary = true) {
                    const segments = [];
                    let currentElement = element;
                    while (currentElement &&
                        currentElement.nodeType === Node.ELEMENT_NODE) {
                        if (stopAtBoundary &&
                            (currentElement.parentNode instanceof ShadowRoot ||
                                currentElement.parentNode instanceof HTMLIFrameElement)) {
                            break;
                        }
                        let index = 0;
                        let sibling = currentElement.previousSibling;
                        while (sibling) {
                            if (sibling.nodeType === Node.ELEMENT_NODE &&
                                sibling.nodeName === currentElement.nodeName) {
                                index++;
                            }
                            sibling = sibling.previousSibling;
                        }
                        const tagName = currentElement.nodeName.toLowerCase();
                        const xpathIndex = index > 0 ? `[${index + 1}]` : '';
                        segments.unshift(`${tagName}${xpathIndex}`);
                        currentElement = currentElement.parentNode;
                    }
                    return segments.join('/');
                }
                function isElementAccepted(element) {
                    const leafElementDenyList = new Set([
                        'svg',
                        'script',
                        'style',
                        'link',
                        'meta',
                    ]);
                    return !leafElementDenyList.has(element.tagName.toLowerCase());
                }
                function isInteractiveElement(element) {
                    const interactiveElements = new Set([
                        'a',
                        'button',
                        'details',
                        'embed',
                        'input',
                        'label',
                        'menu',
                        'menuitem',
                        'object',
                        'select',
                        'textarea',
                        'summary',
                    ]);
                    const interactiveRoles = new Set([
                        'button',
                        'menu',
                        'menuitem',
                        'link',
                        'checkbox',
                        'radio',
                        'slider',
                        'tab',
                        'tabpanel',
                        'textbox',
                        'combobox',
                        'grid',
                        'listbox',
                        'option',
                        'progressbar',
                        'scrollbar',
                        'searchbox',
                        'switch',
                        'tree',
                        'treeitem',
                        'spinbutton',
                        'tooltip',
                        'a-button-inner',
                        'a-dropdown-button',
                        'click',
                        'menuitemcheckbox',
                        'menuitemradio',
                        'a-button-text',
                        'button-text',
                        'button-icon',
                        'button-icon-only',
                        'button-text-icon-only',
                        'dropdown',
                        'combobox',
                    ]);
                    const tagName = element.tagName.toLowerCase();
                    const role = element.getAttribute('role') ?? '';
                    const ariaRole = element.getAttribute('aria-role') ?? '';
                    const tabIndex = element.getAttribute('tabindex') ?? '';
                    const hasAddressInputClass = element.classList.contains('address-input__container__input');
                    const hasInteractiveRole = hasAddressInputClass ||
                        interactiveElements.has(tagName) ||
                        interactiveRoles.has(role) ||
                        interactiveRoles.has(ariaRole) ||
                        (tabIndex !== null && tabIndex !== '-1') ||
                        element.getAttribute('data-action') === 'a-dropdown-select' ||
                        element.getAttribute('data-action') === 'a-dropdown-button';
                    if (hasInteractiveRole)
                        return true;
                    const hasClickHandler = element.onclick !== null ||
                        element.getAttribute('onclick') !== null ||
                        element.hasAttribute('ng-click') ||
                        element.hasAttribute('@click') ||
                        element.hasAttribute('v-on:click');
                    function getEventListeners(el) {
                        try {
                            return window.getEventListeners?.(el) || {};
                        }
                        catch (e) {
                            const listeners = {};
                            const eventTypes = [
                                'click',
                                'mousedown',
                                'mouseup',
                                'touchstart',
                                'touchend',
                                'keydown',
                                'keyup',
                                'focus',
                                'blur',
                            ];
                            for (const type of eventTypes) {
                                const handler = el[`on${type}`];
                                if (handler) {
                                    listeners[type] = [
                                        {
                                            listener: handler,
                                            useCapture: false,
                                        },
                                    ];
                                }
                            }
                            return listeners;
                        }
                    }
                    const listeners = getEventListeners(element);
                    const hasClickListeners = listeners &&
                        (listeners.click?.length > 0 ||
                            listeners.mousedown?.length > 0 ||
                            listeners.mouseup?.length > 0 ||
                            listeners.touchstart?.length > 0 ||
                            listeners.touchend?.length > 0);
                    const hasAriaProps = element.hasAttribute('aria-expanded') ||
                        element.hasAttribute('aria-pressed') ||
                        element.hasAttribute('aria-selected') ||
                        element.hasAttribute('aria-checked');
                    const isDraggable = element.draggable || element.getAttribute('draggable') === 'true';
                    return (hasAriaProps || hasClickHandler || hasClickListeners || isDraggable);
                }
                function isElementVisible(element) {
                    const style = window.getComputedStyle(element);
                    return (element.offsetWidth > 0 &&
                        element.offsetHeight > 0 &&
                        style.visibility !== 'hidden' &&
                        style.display !== 'none');
                }
                function isTopElement(element) {
                    const rect = element.getBoundingClientRect();
                    if (rect.bottom < 0 || rect.top > window.innerHeight)
                        return false;
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const topEl = document.elementFromPoint(centerX, centerY);
                    return topEl === element || element.contains(topEl);
                }
                function isTopElementOld(element) {
                    let doc = element.ownerDocument;
                    if (doc !== window.document) {
                        return true;
                    }
                    const shadowRoot = element.getRootNode();
                    if (shadowRoot instanceof ShadowRoot) {
                        const rect = element.getBoundingClientRect();
                        const point = {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2,
                        };
                        try {
                            const topEl = shadowRoot.elementFromPoint(point.x, point.y);
                            if (!topEl)
                                return false;
                            let current = topEl;
                            while (current && current !== shadowRoot) {
                                if (current === element)
                                    return true;
                                current = current.parentElement;
                            }
                            return false;
                        }
                        catch (e) {
                            return true;
                        }
                    }
                    const rect = element.getBoundingClientRect();
                    if (viewportExpansion === -1) ;
                    const scrollX = window.scrollX;
                    const scrollY = window.scrollY;
                    const viewportTop = -viewportExpansion + scrollY;
                    const viewportLeft = -viewportExpansion + scrollX;
                    const viewportBottom = window.innerHeight + viewportExpansion + scrollY;
                    const viewportRight = window.innerWidth + viewportExpansion + scrollX;
                    const absTop = rect.top + scrollY;
                    const absLeft = rect.left + scrollX;
                    const absBottom = rect.bottom + scrollY;
                    const absRight = rect.right + scrollX;
                    if (absBottom < viewportTop ||
                        absTop > viewportBottom ||
                        absRight < viewportLeft ||
                        absLeft > viewportRight) {
                        return false;
                    }
                    try {
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        const point = {
                            x: centerX,
                            y: centerY,
                        };
                        if (point.x < 0 ||
                            point.x >= window.innerWidth ||
                            point.y < 0 ||
                            point.y >= window.innerHeight) {
                            return true;
                        }
                        const topEl = document.elementFromPoint(point.x, point.y);
                        if (!topEl)
                            return false;
                        let current = topEl;
                        while (current && current !== document.documentElement) {
                            if (current === element)
                                return true;
                            current = current.parentElement;
                        }
                        return false;
                    }
                    catch (e) {
                        return true;
                    }
                }
                function isTextNodeVisible(textNode) {
                    const range = document.createRange();
                    range.selectNodeContents(textNode);
                    const rect = range.getBoundingClientRect();
                    return (rect.width !== 0 &&
                        rect.height !== 0 &&
                        rect.top >= 0 &&
                        rect.top <= window.innerHeight &&
                        textNode.parentElement?.checkVisibility({
                            checkOpacity: true,
                            checkVisibilityCSS: true,
                        }));
                }
                function getCoordinates(element) {
                    const rect = element.getBoundingClientRect();
                    if (!rect)
                        return null;
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    if (isNaN(centerX) || isNaN(centerY))
                        return null;
                    if (centerX <= 0 || centerY <= 0)
                        return null;
                    return {
                        x: centerX,
                        y: centerY,
                    };
                }
                function buildDomTree(node, parentIframe = null) {
                    if (!node)
                        return null;
                    if (node.nodeType === Node.TEXT_NODE) {
                        const textContent = node.textContent?.trim() ?? '';
                        if (textContent && isTextNodeVisible(node)) {
                            return {
                                type: 'TEXT_NODE',
                                text: textContent,
                                isVisible: true,
                            };
                        }
                        return null;
                    }
                    if (node.nodeType === Node.ELEMENT_NODE && !isElementAccepted(node)) {
                        return null;
                    }
                    const nodeData = {
                        tagName: node.tagName ? node.tagName.toLowerCase() : null,
                        attributes: {},
                        xpath: node.nodeType === Node.ELEMENT_NODE
                            ? getXPathTree(node, true)
                            : null,
                        children: [],
                    };
                    if (node.nodeType === Node.ELEMENT_NODE && node.attributes) {
                        const attributeNames = node.getAttributeNames?.() || [];
                        if (!nodeData.attributes) {
                            nodeData.attributes = {};
                        }
                        for (const name of attributeNames) {
                            nodeData.attributes[name] = node.getAttribute(name) ?? '';
                        }
                    }
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const isInteractive = isInteractiveElement(node);
                        const isVisible = isElementVisible(node);
                        const coordinates = getCoordinates(node);
                        const isTop = isTopElement(node);
                        nodeData.isInteractive = isInteractive;
                        nodeData.isVisible = isVisible;
                        nodeData.isTopElement = isTop;
                        nodeData.text = '';
                        nodeData.coordinates = coordinates;
                        if (isInteractive && isVisible && isTop) {
                            nodeData.highlightIndex = highlightIndex++;
                            if (doHighlightElements) {
                                if (focusHighlightIndex >= 0) ;
                                else {
                                    highlightElement(node, nodeData.highlightIndex, parentIframe);
                                }
                            }
                        }
                    }
                    if (node.shadowRoot) {
                        nodeData.shadowRoot = true;
                    }
                    if (node.shadowRoot) {
                        const shadowChildren = Array.from(node.shadowRoot.childNodes).map((child) => buildDomTree(child, parentIframe));
                        nodeData.children?.push(...shadowChildren);
                    }
                    if (node.tagName === 'IFRAME') {
                        try {
                            const iframeDoc = node.contentDocument ||
                                node.contentWindow?.document;
                            if (iframeDoc) {
                                const iframeChildren = Array.from(iframeDoc.body.childNodes).map((child) => buildDomTree(child, node));
                                nodeData.children?.push(...iframeChildren);
                            }
                        }
                        catch (e) {
                            console.warn('Unable to access iframe:', node);
                        }
                    }
                    else {
                        const children = Array.from(node.childNodes).map((child) => buildDomTree(child, parentIframe));
                        nodeData.children?.push(...children);
                    }
                    return nodeData;
                }
                const domTree = buildDomTree(document.body);
                return domTree;
            }, withHighlight);
            return domState;
        }
        catch (error) {
            console.log('error', error);
            return null;
        }
    }
}

class InMemoryFileSystem {
    constructor() { }
    saveFile(path, data) {
        return this.saveScreenshot(path, data);
    }
    saveScreenshot(filename, data) {
        return new Promise((resolve, reject) => {
            try {
                const base64Data = data.toString("base64");
                const url = `data:image/png;base64,${base64Data}`;
                resolve(url);
            }
            catch (error) {
                reject(error);
            }
        });
    }
}

class OpenAI4o {
    constructor(openAiApiKey) {
        this.model = new ChatOpenAI({
            model: 'gpt-4o',
            temperature: 0,
            openAIApiKey: openAiApiKey,
        });
    }
    async invokeAndParse(messages, parser) {
        const response = await this.model.invoke(messages, {
            response_format: { type: 'json_object' },
        });
        return parser.invoke(response);
    }
}

class PlaywrightScreenshoter {
    constructor(fileSystem) {
        this.fileSystem = fileSystem;
    }
    async takeScreenshot(page) {
        const screenshot = await page.screenshot({
            type: "png",
            fullPage: false,
        });
        const url = new URL(page.url());
        const hostname = url.hostname.replace(/[:/]/g, "_");
        const segments = url.pathname
            .split("/")
            .filter((segment) => segment)
            .join("_");
        const key = `${hostname}_${segments}_${crypto.randomUUID()}`;
        const signedUrl = await this.fileSystem.saveScreenshot(key, screenshot);
        return signedUrl;
    }
}

const initOpenator = (options) => {
    const fileSystem = new InMemoryFileSystem();
    const screenshotService = new PlaywrightScreenshoter(fileSystem);
    const browser = new ChromiumBrowser({
        headless: options.headless,
    });
    const llm = new OpenAI4o(options.openAiApiKey);
    const eventBus = new EventBus();
    const domService = new DomService(screenshotService, browser, eventBus);
    const feedbackAgent = new FeedbackAgent(llm);
    const taskManager = new TaskManagerService();
    const summarizer = initSummarizer(options.openAiApiKey, llm);
    const summarizeTask = initSummarizeTask();
    return new Openator({
        variables: [],
        taskManager,
        domService,
        browserService: browser,
        llmService: llm,
        feedbackAgent,
        reporter: new ConsoleReporter('Openator'),
        summarizer,
        summarizeTask,
    });
};

export { initOpenator };
//# sourceMappingURL=index.js.map
